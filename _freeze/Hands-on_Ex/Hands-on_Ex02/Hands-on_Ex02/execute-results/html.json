{
  "hash": "d76ee10445c570b17759ae4b28a5fa52",
  "result": {
    "markdown": "---\ntitle: \"Hands-on Exercise 2: Choropleth Mapping with R\"\nexecute: \n  warning: false\n  freeze: true\n  eval: false\ndate: \"2024-02-13\"\n---\n\n\n# 2.1 Getting Started\n\nIn this exercise, I will:\n\n-   plot choropleth maps using the `tmap` package\n\n## 2.1.1 Datasets\n\n-   **Geospatial:** [Master Plan 2014 Subzone Boundary (Web)](https://beta.data.gov.sg/datasets/d_5cb80a95445f236737f6bc2bfe5f159d/view)\n\n-   **Aspatial:** [Singapore Residents by Planning Area / Subzone, Age Group, Sex and Type of Dwelling, June 2011-2020](https://www.singstat.gov.sg/find-data/search-by-theme/population/geographic-distribution/latest-data)\n\n## 2.1.2 R Packages\n\nThe following packages will be used in this exercise:\n\n-   [**readr**](https://readr.tidyverse.org/) for importing delimited text file\n\n-   [**tidyr**](https://tidyr.tidyverse.org/) for tidying data\n\n-   [**dplyr**](https://dplyr.tidyverse.org/) for wrangling data\n\n-   [**sf**](https://cran.r-project.org/web/packages/sf/) for handling geospatial data\n\n-   [**tmap**](https://cran.r-project.org/web/packages/tmap/) for plotting choropleth maps\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, tmap, tidyverse)\n```\n:::\n\n\n# 2.2 Importing Data into R\n\n## 2.2.1 Importing Geospatial Data into R\n\nUse the `st_read()` function of **sf** package to import `MP14_SUBZONE_WEB_PL` shapefile into R as a simple feature data frame called `mpsz`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz <- st_read(dsn=\"data/geospatial\",\n                layer=\"MP14_SUBZONE_WEB_PL\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz\n```\n:::\n\n\n## 2.2.2 Importing **Attribute** Data into R\n\nUsing `read_csv()` function of **readr** package, we will read the DOS csv file.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopdata <- read_csv(\"data/aspatial/respopagesextod2011to2020.csv\")\n```\n:::\n\n\n## 2.2.3 Preparing Data\n\nA data table containing values for the year 2020 is needed for creating the thematic map. This table should include variables such as PA (Planning Area), SZ (Subzone), and AG (Age Group), which consists of ECONOMY ACTIVE, AGED, TOTAL, and DEPENDENCY categories.\n\n-   **YOUNG**: age group 0 to 4 until age group 20 to 24\n\n-   **ECONOMY ACTIVE**: age group 25-29 until age group 60-64\n\n-   **AGED**: age group 65 and above\n\n-   **TOTAL**: all age group\n\n-   **DEPENDENCY**: the ratio between young and aged against economy active group\n\n## 2.2.3.1 Wrangling Data\n\nTo wrangle the data, the following functions will be used:\n\n`pivot_wider()` of tidyr package, and `mutate()`, `filter()`, `group_by()` and `select()` of dplyr package\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Filter data for the year 2020 and group by Planning Area (PA), Subzone (SZ), and Age Group (AG)\npopdata2020 <- popdata %>%\n  filter(`Time` == 2020) %>%\n  group_by(PA, SZ, AG) %>% \n  \n  # Create a new data frame with total population for each group\n  summarise(`POP` = sum(`Pop`)) %>%\n  \n  # Ungroup after grouping to create summaries for each grouping\n  ungroup() %>%\n  \n  # Pivot the data to increase the number of columns and decrease the number of rows\n  pivot_wider(names_from = AG, values_from = POP) %>%\n  \n  # Add new variables and preserve existing ones\n  mutate(\n    YOUNG = rowSums(.[3:6]) + rowSums(.[12]),\n    `ECONOMY ACTIVE` = rowSums(.[7:11]) + rowSums(.[13:15]),\n    `AGED` = rowSums(.[16:21]),\n    `TOTAL` = rowSums(.[3:21]),\n    `DEPENDENCY` = (`YOUNG` + `AGED`) / `ECONOMY ACTIVE`\n  ) %>%\n  \n  # Select specific columns for the final data frame\n  select(`PA`, `SZ`, `YOUNG`, `ECONOMY ACTIVE`, `AGED`, `TOTAL`, `DEPENDENCY`)\n\n# View the resulting data frame\npopdata2020\n```\n:::\n\n\n## 2.2.3.2 Joining the Attribute Data and Geospatial Data\n\nIt is necessary to convert the PA and SZ fields to uppercase. This is because these fields contain a mix of upper- and lowercase values, unlike the SUBZONE_N and PLN_AREA_N fields, which consistently use uppercase characters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopdata2020 <- popdata2020 %>%\n                mutate_at(.vars = vars(PA, SZ),\n                          .funs = funs(toupper)) %>%\n                filter(`ECONOMY ACTIVE` > 0)\npopdata2020\n```\n:::\n\n\n`left_join()` of dplyr is used to join the attribute data and geospatial data using planning subzone name.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz_pop2020 <- left_join(mpsz, popdata2020,\n                          by = c(\"SUBZONE_N\" = \"SZ\"))\nmpsz_pop2020\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(mpsz_pop2020, \"data/rds/mpszpop2020.rds\")\n```\n:::\n\n\n# 2.3 Choropleth Mapping Geospatial Data Using tmap\n\nTwo methods can be employed to create a thematic map using tmap:\n\n1.  Quickly generating a thematic map by utilising `qtm()`.\n2.  Plotting a highly customisable thematic map through the use of tmap elements.\n\n## 2.3.1 Plotting a choropleth map with `qtm()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\") \nqtm(mpsz_pop2020,\n    fill = \"DEPENDENCY\")\n```\n:::\n\n\n## 2.3.2 Plotting a choropleth map with tmap’s elements\n\nOne disadvantge of `qtm()` is that it makes aesthetics of individual layers harder to control.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          style = \"quantile\",\n          palette = \"Blues\",\n          title = \"Dependency ratio\") +\n  tm_layout(main.title = \"Distribution of Dependency Ratio by planning subzone\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45,\n            legend.width = 0.35,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5) + \n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar() +\n  tm_grid(alpha = 0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\\n and Population data from Department of Statistics DOS\",\n             position = c(\"left\", \"bottom\"))\n```\n:::\n\n\n## 2.3.2.1 Plotting a base map\n\nThe core of tmap is built using `tm_shape()`, and additional layer elements like `tm_fill()` and `tm_polygons()` are used. In the given code snippet, `tm_shape()` defines the input data (`mpsz_pop2020`), and `tm_polygons()` is used to draw the planning subzone polygons.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n  tm_polygons()\n```\n:::\n\n\n## 2.3.2.2 Drawing a choropleth map using `tm_polygons()`\n\nTo make a choropleth map displaying the variable distribution across planning subzones, assign the target variable (e.g., Dependency) to tm_polygons().\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n  tm_polygons(\"DEPENDENCY\")\n```\n:::\n\n\n## 2.3.2.3 Drawing a choropleth map using `tm_fill()` and `tm_border()`\n\n`tm_polygons()` wraps `tm_fill()` for shading polygons and `tm_borders()` for adding shapefile borders to the choropleth map.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n  tm_polygons(\"DEPENDENCY\")\n```\n:::\n\n\nTo add the boundary of the planning subzones, `tm_borders()` is used.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\") +\n  tm_borders(lwd = 0.1, alpha = 1)\n```\n:::\n\n\nIn addition to the alpha argument, `tm_borders()` has three other options:\n\n-   *col* = border colour,\n\n-   *lwd* = border line width. The default is 1, and\n\n-   *lty* = border line type. The default is “solid”.\n\n## 2.3.3 Data classification methods of tmap\n\nChoropleth maps often use data classification methods to group numerous observations into ranges or classes.\n\ntmap offers ten classification methods: pretty (default), equal, jenks, fixed, sd, quantile, kmeans, hclust, bclust, and fisher.\n\nTo specify a data classification method, use the style argument in `tm_fill()` or `tm_polygons()`.\n\n## 2.4.3.1 Plotting choropleth maps with built-in classification methods\n\nThe following shows quantile data classification.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5)\n```\n:::\n\n\nThe following shows an equal data classification method.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5)\n```\n:::\n\n\nThe following shows fixed data classification method.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"fixed\",\n          breaks = c(0, 2, 6, 13, 19)) + \n  tm_borders(alpha = 0.5)\n```\n:::\n\n\nThe following shows standard deviation method.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"sd\") +\n  tm_borders(alpha = 0.5)\n```\n:::\n\n\nThe following shows quantile method.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5)\n```\n:::\n\n\nThe following shows KMeans method.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"kmeans\") +\n  tm_borders(alpha = 0.5)\n```\n:::\n\n\nThe following shows hclust method.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"hclust\") +\n  tm_borders(alpha = 0.5)\n```\n:::\n\n\nThe following shows bclust method.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"bclust\") +\n  tm_borders(alpha = 0.5)\n```\n:::\n\n\nThe following shows fisher method.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"fisher\") +\n  tm_borders(alpha = 0.5)\n```\n:::\n\n\n## 2.4.3.2 Experimenting with Different Number of Classes\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          n = 20,\n          style = \"pretty\") +\n  tm_borders(alpha = 0.5)\n```\n:::\n\n\n## 2.4.3.3 Plotting choropleth map with custom break\n\nTo customize category breaks in tmap, use the breaks argument in `tm_fill()`. Specify n+1 elements in breaks for n categories (values in increasing order).\n\nThe provided code calculates and displays descriptive statistics for the DEPENDENCY field.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(mpsz_pop2020$DEPENDENCY)\n```\n:::\n\n\nNow, we will plot the choropleth map by using the values we obtained from the previous output.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          breaks = c(0, 0.60, 0.70, 0.80, 0.90, 1.00)) +\n  tm_borders(alpha = 0.5)\n```\n:::\n\n\n## 2.4.4 Colour Scheme\n\ntmap supports colour ramps either defined by the user or a set of predefined colour ramps from the RColorBrewer package.\n\n## 2.4.4.1 Using ColourBrewer palette\n\nThe chosen colour will be assigned to the palette argument of `tm_fill()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          n = 6,\n          style = \"quantile\",\n          palette = \"Blues\") +\n  tm_borders(alpha = 0.5)\n```\n:::\n\n\nTo reverse the colour shading, add a “-” prefix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          style = \"quantile\",\n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5)\n```\n:::\n\n\n## 2.4.5 Map Layouts\n\n## 2.4.5.1 Map Legend\n\ntmap offers various legend options that allow you to modify the placement, format, and appearance of the legend.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"jenks\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(main.title = \"Distribution of Dependency Ratio by planning subzone \\n(Jenks classification)\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            legend.outside = FALSE,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n```\n:::\n\n\n## 2.4.5.2 Map style\n\ntmap enables the alteration of numerous layout settings, accessible through `tmap_style()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"classic\")\n```\n:::\n\n\n## 2.4.5.3 Cartographic Furniture\n\ntmap also also provides arguments to draw other map furniture such as compass, scale bar and grid lines.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\",\n          title = \"No. of persons\") +\n  tm_layout(main.title = \"Distribution of Dependency Ratio \\nby planning subzone\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\\n and Population data from Department of Statistics DOS\", \n             position = c(\"left\", \"bottom\"))\n```\n:::\n\n\n## 2.4.6 Drawing Small Multiple Choropleth Maps\n\nFacet maps consist of multiple maps arranged either side-by-side or stacked vertically. They are useful for visualising changes in spatial relationships concerning another variable, like time.\n\nIn tmap, facet maps can be created in three ways:\n\n1.  By assigning multiple values to at least one aesthetic argument\n2.  By defining a group-by variable in tm_facets()\n3.  By creating multiple stand-alone maps with tmap_arrange()\n\n## 2.4.6.1 By assigning multiple values to at least one aesthetic argument\n\nFacet maps are created by defining ncols in `tm_fill()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill(c(\"YOUNG\", \"AGED\"),\n          style = \"equal\", \n          palette = \"Blues\") +\n  tm_layout(legend.position = c(\"right\", \"bottom\")) +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"white\")\n```\n:::\n\n\nIn this example, small multiple choropleth maps are created by assigning multiple values to at least one of aesthetic arguments\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+ \n  tm_polygons(c(\"DEPENDENCY\",\"AGED\"),\n          style = c(\"equal\", \"quantile\"), \n          palette = list(\"Blues\",\"Greens\")) +\n  tm_layout(legend.position = c(\"right\", \"bottom\"))\n```\n:::\n\n\n## 2.4.6.2 By defining a group-by variable in `tm_facets()`\n\nFacet maps are created using `tm_facets()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          style = \"quantile\",\n          palette = \"Blues\",\n          thres.poly = 0) + \n  tm_facets(by=\"REGION_N\", \n            free.coords=TRUE, \n            drop.shapes=TRUE) +\n  tm_layout(legend.show = FALSE,\n            title.position = c(\"center\", \"center\"), \n            title.size = 20) +\n  tm_borders(alpha = 0.5)\n```\n:::\n\n\n## 2.4.6.3 By creating multiple stand-alone maps with `tmap_arrange()`\n\nFacet maps are created by creating multiple stand-alone maps with `tmap_arrange()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nyoungmap <- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"YOUNG\", \n              style = \"quantile\", \n              palette = \"Blues\")\n\nagedmap <- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"AGED\", \n              style = \"quantile\", \n              palette = \"Blues\")\n\ntmap_arrange(youngmap, agedmap, asp=1, ncol=2)\n```\n:::\n\n\n## 2.4.7 Mapping Spatial Object Meeting a Selection Criterion\n\nWe can also use selection funtion to map spatial objects meeting the selection criterion.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020[mpsz_pop2020$REGION_N==\"CENTRAL REGION\", ])+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(legend.outside = TRUE,\n            legend.height = 0.45, \n            legend.width = 5.0,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}