---
title: "Take-home Exercise 1: Application of Spatial Point Patterns Analysis to Discover the Geographical Distribution of Grab Hailing Services in Singapore"
format: 
  html:
    code-fold: true
    code-summary: "Show the code"
    #toc: false
execute: 
  eval: true
  echo: true
  warning: false
editor: visual
---

# 1 Overview

## 1.1 Setting the scene

Understanding how people move around in a city is like figuring out its heartbeat—it shows us the rhythms that shape our urban lives. Thanks to smartphones and technology, we now have a bunch of data about how people move. When we use smart analysis tools like GIS, we can unlock valuable insights that help us plan cities better.

In 2020, GRAB shared a set of data called Grab Posisi, all about how people move around in Singapore. This kind of information isn't just interesting; it's super helpful for businesses, people who make decisions about the city, and those who plan how cities work. It's like having a dynamic picture of how people move, helping us create cities that work well for everyone.

## 1.2 Objectives

The objectives of this exercise are to:

-   Apply geospatial analytics to address societal challenges

-   Use spatial point patterns analysis methods to explore Grab hailing services distribution in Singapore

-   Organise geospatial data into sf tibble data.frames using sf and tidyverse functions

-   Focus on Grab taxi location points, road layer within Singapore, and Singapore boundary layer

-   Generate traditional Kernel Density Estimation layers from the extracted data

-   Create either Network Kernel Density Estimation (NKDE)

-   Utilise tmap functions to display kernel density layers on an openstreetmap of Singapore

-   Describe spatial patterns revealed by the kernel density maps

By this exercise, I will:

-   Enhance my understanding of geospatial analytics applications

-   Develop proficiency in spatial point patterns analysis

-   Gain hands-on experience in organising geospatial data using sf and tidyverse functions

-   Explore Grab hailing services distribution patterns in Singapore

-   Generate and interpret Kernel Density Estimation layers

-   Understand the nuances of Network Kernel Density Estimation (NKDE)

-   Master the visualisation of spatial patterns using tmap functions on an openstreetmap

# 2 Getting Started

## 2.1 Data Acquisition

The study will utilise the following datasets to explore spatial point patterns analysis methods and reveal the geographical and spatio-temporal distribution of Grab hailing services locations in Singapore.

| Dataset Name                               | Type                | Source                                                              | Path                                     |
|-----------------|-----------------|---------------------|-----------------|
| Grab-Posisi                                | Aspatial (.parquet) | <https://engineering.grab.com/grab-posisi>                          | data/aspatial/grabPosisi                 |
| Master Plan 2019 Subzone Boundary (No Sea) | Geospatial (.shp)   | <https://beta.data.gov.sg/collections/2104/view>                    | data/geospatial/MPSZ-2019                |
| Open Street Map Raod Data                  | Geospatial (.shp)   | <https://download.geofabrik.de/asia/malaysia-singapore-brunei.html> | data/geospatial/OSM/gis_osm_roads_free_1 |

## **2.2 Importing Relevant R Packages**

The R packages used in this project are:

-   `sf`: for importing, managing, and processing geospatial data.

-   `tidyverse`: a family of other R packages for performing data science tasks such as importing, wrangling, and visualising data.

-   `tmap`: creating thematic maps

-   `maptools`: a set of tools for manipulating geographic data

-   `raster`: reads, writes, manipulates, analyses, and model gridded spatial data (raster)

-   `spatstat`: for performing spatial point patterns analysis

-   `dplyr`

-   `arrow`

-   `lubridate`: undefined

-   `rgdal`
- `RcolorBrewer`

Pacman assists us by helping us load R packages that we require.

```{r}
  pacman::p_load(arrow, lubridate, tidyverse, tmap, sf, maptools, spatstat, raster, dplyr, rmapshaper, RColorBrewer)
#update.packages(ask = FALSE, dependencies = TRUE)
## install.packages("maptools", repos = "https://packagemanager.posit.co/cran/2023-10-13")
```

## 2.3 Importing Geospatial Datasets

## 2.3.1 Master Plan 2019 Subzone Boundary (No Sea)

For the shapefile format, two arguments are required: `dsn` to define the data path, and `layer` to provide the shapefile name. 

```{r}
mpsz_sf <- st_read(dsn = "data/geospatial", 
                layer = "MPSZ-2019") %>%
    st_transform(crs = 3414)
```

::: callout-important
**Project Transformation**

Given that our dataset corresponds to the geographical boundaries of Singapore, it is necessary to specify the appropriate CRS for accurate spatial analysis. To achieve this, the **`st_transform()`** function is used to convert the CRS of `mpsz_sf` to SVY21 (EPSG: 3414)
:::

## 2.3.2 Coastal Outline

In order to create a costal outline of singapore, we will use the `st_union` function to consolidate all subzone boundaries into a single polygon.

```{r}
outline = mpsz_sf %>% st_union()
plot(outline)
```

## 2.3.2.1 Extracting outer islands

As seen in the figure above, the coastal outline includes outer islands where Grab service is unavailable. Through the code chunk below, we shall use the `subset` function to select planning subzones from the `mpsz_sf` dataset to exclude. These rows of data are stored in new dataframes.

```{r}
semakau <- subset(mpsz_sf,mpsz_sf$SUBZONE_N == "SEMAKAU") #western island
sudong <- subset(mpsz_sf, mpsz_sf$SUBZONE_N == "SUDONG") #western island
bukom <- subset(mpsz_sf, mpsz_sf$SUBZONE_N ==  "JURONG ISLAND AND BUKOM")
north <- subset(mpsz_sf, mpsz_sf$SUBZONE_N == "NORTH-EASTERN ISLANDS")
south <- subset(mpsz_sf, mpsz_sf$SUBZONE_N == "SOUTHERN GROUP")
```

We combine the newly created dataframes using the `bind_rows` function.

```{r}
outer <- dplyr::bind_rows(list(semakau,sudong,bukom,north,south))
```

## 2.3.2.2 Rendering a Coastal Boundary Excluding Outer Islands

We use the st_union function to merge the geometries of `mpsz_sf` and `outerislands` and the `st_difference` function to eliminate the overlap.

```{r}
sg_sf <- st_difference(st_union(mpsz_sf), st_union(outer))
plot(sg_sf)
```

::: callout-tip
✅ Task Complete! We have extracted Singapore boundary layer excluding outer islands.
:::

## 2.3.3 Open Street Map Road Data

```{r}
allroads = st_read(dsn = "data/geospatial/OSM", 
                         layer = "gis_osm_roads_free_1")  %>% st_transform(crs = 3414)
```

::: callout-important
**Project Transformation**

Given that our dataset corresponds to the geographical boundaries of Singapore, it's necessary to specify the appropriate CRS for accurate spatial analysis. To achieve this, the **`st_transform()`** function is used to convert the CRS of `allroads` to SVY21 (EPSG: 3414)
:::

This dataset encompasses road networks spanning Singapore, Malaysia, and Brunei. To narrow our focus, we will extract roads exclusively within the Singapore boundary using the `st_intersection` function.

```{r}
sg_roads_all <- st_intersection(allroads,sg_sf)
```

Next, we will examine the road network's road types.

```{r}
unique(sg_roads_all$fclass)
```

Given our focus on Grab services, which primarily operate on roads excluding expressways, we will extract the relevant types from the road network. We can refer to OSM fclass to understand whichi roads are relevant here.

```{r}
sg_roads_filtered <- c("primary", "residential", "tertiary", "service", "secondary", "primary_link", "secondary_link", "tertiary_link")
 
```

```{r}
sg_roads <- sg_roads_all[sg_roads_all$fclass %in% sg_roads_filtered, ]

unique(sg_roads$fclass)
```

We will now visualise the selected road types within the boundaries of Singapore.

```{r}
road_type_palette <- brewer.pal(12, "Set3")
tm_shape(sg_sf) + 
  tm_borders(lwd = 2, col = 'grey') +
  tm_shape(sg_roads) + 
  tm_lines(col = "fclass", palette = road_type_palette)
  tm_layout(frame = FALSE)

```

::: callout-tip
✅ Task Complete! Road layer within Singapore excluding outer islands.
:::

## 2.4 Importing Aspatial Datasets

## 2.4.1 Grab-Posisi

Grab-Posisi, is a GPS trajectory dataset. Each trajectory is serialised in a file in Apache Parquet format. 

We will use the `read_parquet` function from the `arrow` package, to read Parquet files.

```{r}
grab0 <- read_parquet("data/aspatial/GrabPosisi/part-00000.parquet", as_data_frame = TRUE)
grab1 <- read_parquet("data/aspatial/GrabPosisi/part-00001.parquet", as_data_frame = TRUE)
grab2 <- read_parquet("data/aspatial/GrabPosisi/part-00002.parquet", as_data_frame = TRUE)
grab3 <- read_parquet("data/aspatial/GrabPosisi/part-00003.parquet", as_data_frame = TRUE)
grab4 <- read_parquet("data/aspatial/GrabPosisi/part-00004.parquet", as_data_frame = TRUE)
grab5 <- read_parquet("data/aspatial/GrabPosisi/part-00005.parquet", as_data_frame = TRUE)
grab6 <- read_parquet("data/aspatial/GrabPosisi/part-00006.parquet", as_data_frame = TRUE)
grab7 <- read_parquet("data/aspatial/GrabPosisi/part-00007.parquet", as_data_frame = TRUE)
grab8 <- read_parquet("data/aspatial/GrabPosisi/part-00008.parquet", as_data_frame = TRUE)
grab9 <- read_parquet("data/aspatial/GrabPosisi/part-00009.parquet", as_data_frame = TRUE)
```

Then we join all into one dataframe.

```{r}
grab <- bind_rows(grab0,grab1, grab2,grab3,grab4,grab5,grab6,grab7,grab8,grab9) 
```

```{r}
head(grab)
```

The `head` function reveals that there are 9 columns in the dataframe.

The field `pingtimestamp` is not in proper date-time format. It is stored as an `int` value. The following code chunk converts the data type of `pingtimestamp` from `int` to `date-time` format.

```{r}
grab$pingtimestamp <- as_datetime(grab$pingtimestamp)
```

## 2.4.1.2 Converting Aspatial Data Frame into a Simple Feature Data Frame

We will proceed to convert the `grab` dataset, currently in an aspatial data frame, into an sf tibble dataframe.

```{r}
#| eval: false
grab_sf <- st_as_sf(grab, 
                       coords = c("rawlng", "rawlat"),
                       crs=4326) %>%
  st_transform(crs = 3414)
```

```{r}
# write_rds(grab_sf, "data/rds/grab_sf.rds")
grab_sf <- read_rds("data/rds/grab_sf.rds")
```

::: callout-important
**Project Transformation**

Assuming the dataset is initially in the WGS84 Geographic Coordinate System, as indicated by its latitude/longitude fields, we need to define the suitable CRS for spatial analysis within Singapore. The `st_transform()` function is utilised to convert the CRS of the `grab` dataset to SVY21 (EPSG: 3414).
:::

This gives us the new simple feature data frame, `grab_sf`

## 2.4.2 Data Wrangling

## 2.4.2.1 **Extracting Grab Trips Starting Locations**

We will extract trip starting point for all unqiue trajectories and store them to a new df named `grab_origin`. To isolate the origin locations, we employ the following methodology:

1.  **Grouping by Trajectory ID:**

    -   The dataset is grouped by the unique trajectory identifier (**`trj_id`**).

2.  **Arranging by Timestamp:**

    -   Within each trajectory group, records are arranged in ascending order based on the timestamp (**`pingtimestamp`**).

3.  **Filtering for the First Row:**

    -   By selecting the first row within each grouped trajectory (**`row_number() == 1`**), we identify the earliest recorded location for each trip. This is indicative of the trip's starting point.

4.  **Adding Temporal Information:**

    -   Additional temporal context is provided by introducing new columns:

        -   **`weekday`**: Day of the week based on the timestamp.

        -   **`start_hr`**: Starting hour of the trip.

        -   **`day`**: Day of the month when the trip commenced.

```{r}
#| eval: false
grab_origin <- grab_sf %>%
  group_by(trj_id) %>%
  arrange(pingtimestamp) %>%
  filter(row_number()==1) %>% #after sorting by timestamp, first row gives origin location 
  mutate(weekday = wday(pingtimestamp, #define workday
                        label = TRUE,
                        abbr = TRUE), #Monday = MON 
        start_hr = factor(hour(pingtimestamp)),
        day = factor(mday(pingtimestamp))) #to change to ordinal scale
```

```{r}
#write_rds(grab_origin, "data/rds/grab_origin.rds")
grab_origin <- read_rds("data/rds/grab_origin.rds")
```
::: callout-tip
✅ Task Complete! Grab taxi location points by origin points.
:::

## 2.4.2.2 **Extracting Trip Ending Locations**

We will extract trip ending point for all unique trajectories and store them to a new df named `grab_dest`. We employ a similar methodology to extracting a trips origin location. Except here, within each trajectory group, records are arranged in descending order based on the timestamp (**`pingtimestamp`**). By selecting the first row within each grouped trajectory (**`row_number() == 1`**), we identify the latest recorded location for each trip. This corresponds to the trip's ending point.

```{r}
#| eval: false
grab_dest <- grab_sf %>%
  group_by(trj_id) %>%
  arrange(desc(pingtimestamp)) %>% #function from dplyr
  filter(row_number()==1) %>% #first row after arranging in desc order gives dest  
  mutate(weekday = wday(pingtimestamp, #define workday
                        label = TRUE,
                        abbr = TRUE), #Monday = MON 
        end_hr = factor(hour(pingtimestamp)),
        day = factor(mday(pingtimestamp))) #to change to ordinal scale
```

```{r}
#write_rds(grab_dest, "data/rds/grab_dest.rds")
grab_dest <- read_rds("data/rds/grab_dest.rds")
```

::: callout-tip
✅ Task Complete! Grab taxi location points either by destination points.
:::

## Converting Simple Features to Planar Point Pattern Objects

Firstly, we’ll need to convert the simple features data frames into Spatial\* classes so we can to do spatial point pattern analysis on it:

```{r}
grab_origin_ppp <- as.ppp(st_coordinates(grab_origin), st_bbox(grab_origin))
plot(grab_origin_ppp)
```

```{r}
grab_dest_ppp <- as.ppp(st_coordinates(grab_dest), st_bbox(grab_dest))
plot(grab_dest_ppp)
```

::: callout-tip
Note: It is not neccessary to change `sg_sf` into a ppp object as it will be converted to `owin` instead.
:::

## Check for duplicates and Handle Data Errors

```{r}
summary(grab_origin_ppp)
summary(grab_dest_ppp)
```

Note: grab_origin_ppp objects has no duplicated points, just to be sure, check again

```{r}
any(duplicated(grab_origin_ppp)) 
any(duplicated(grab_dest_ppp)) 
```

## Introducing the owin object

Usually, when analysing spatial point patterns, we’ll confine our analysis within a certain geographical area - such as the Singapore boundary. In spatstat, an object called owin is specially designed to represent this polygonal region.

## Creating owin object

```{r}
sg_owin <- as.owin(sg_sf)
plot(sg_owin)
```

## Combining Point Events and OWIN Object

Now, we’ll extract the relevant events that are located within Singapore.

```{r}
grab_origin_ppp_sg <- grab_origin_ppp[sg_owin]
plot(grab_origin_ppp_sg)
```

```{r}
grab_dest_ppp_sg <- grab_dest_ppp[sg_owin]
plot(grab_dest_ppp_sg)
```

## Exploratoty Data Analysis

##Point Symbol Maps

## **First-Order Spatial Point Patterns Analysis**

##Rescale `grab_original_ppp_sg` and `grab_dest_ppp_sg`

`grab_original_ppp_sg` and `grab_dest_ppp_sg` is in metres. For futher analysis, we are required to rescale our data to kilometers, we can do so using `rescale().`

```{r}
grab_origin_ppp_sg_km <- rescale(grab_origin_ppp_sg, 1000, 'km')
grab_dest_ppp_sg_km <- rescale(grab_dest_ppp_sg, 1000, 'km')
```

## Kernel Density Estimation

## Automatic bandwidth method

Computing kernel density estimation using automatic bandwidth selection method

-   [`bw.diggle()`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/bw.diggle.html) Cross Validated Bandwidth Selection for Kernel Density

```{r}
kde_grab_origin_sg_bw <- density(grab_origin_ppp_sg_km,
                                   sigma=bw.diggle,
                                   edge=TRUE,
                                   kernel="gaussian")
```

```{r}
plot(kde_grab_origin_sg_bw,main = "Automatic KDE for Origin Points")
```

```{r}
kde_grab_dest_sg_bw <- density(grab_dest_ppp_sg_km,
                                   sigma=bw.diggle,
                                   edge=TRUE,
                                   kernel="gaussian")
```

```{r}
plot(kde_grab_dest_sg_bw,main = "Automatic KDE for Destination Points")
```

## Other spatstat functions for bandwidth

-   [`bw.CvL()`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/bw.CvL.adaptive.html) Cronie and van Lieshout’s Criterion for Bandwidth Selection for Kernel Density

-   [`bw.scott()`](https://www.rdocumentation.org/packages/spatstat/versions/1.64-1/topics/bw.scott) Scott’s Rule for Bandwidth Selection for Kernel Density

-   [`bw.ppl()`](https://search.r-project.org/CRAN/refmans/spatstat.explore/html/bw.pplHeat.html) Likelihood Cross Validation Bandwidth Selection for Kernel Density

```{r}
bw_CvL <- bw.CvL(grab_origin_ppp_sg_km)
bw_CvL
```

```{r}
bw_scott <- bw.scott(grab_origin_ppp_sg_km, isotropic=TRUE) #{r}to return single bandwidth as scott provides 2 different bandwidths for each coordinate
bw_scott
```

```{r}
bw_ppl <- bw.ppl(grab_origin_ppp_sg_km)
bw_ppl
```

```{r}
bw_diggle <- bw.diggle(grab_origin_ppp_sg_km)
bw_diggle
```

Comparing the output of each method methods

```{r}
kde_diggle <- density(grab_origin_ppp_sg_km, bw_diggle)
kde_CvL <- density(grab_origin_ppp_sg_km, bw_CvL)
kde_scott <- density(grab_origin_ppp_sg_km, bw_scott)
kde_ppl <- density(grab_origin_ppp_sg_km, bw_ppl)

par(mfrow = c(2,2))
plot(kde_diggle,main = "kde_diggle")
plot(kde_CvL,main = "kde_CvL")
plot(kde_scott,main = "kde_scott")
plot(kde_ppl,main = "kde_ppl")
```

```{r}
par(mfrow = c(2,2))
hist(kde_diggle,main = "kde_diggle")
hist(kde_CvL,main = "kde_CvL")
hist(kde_scott,main = "kde_scott")
hist(kde_ppl,main = "kde_ppl")
```

## Choosing the most appropriate KDE Selection Method

we choose scott method not much skewness from histogram

## Fixed Bandwidth Selection

```{r}
fixed_bw_scott <- bw.scott(grab_origin_ppp_sg_km)
fixed_bw_scott
```

The values returned are \_\_\_ and \_\_

The we plot to visualised the fixed bandwdht using scott method

```{r}
kde_fixed_bw_scott <- density(grab_origin_ppp_sg_km, fixed_bw_scott)
plot(kde_fixed_bw_scott)
```

## Different Kernel Function Selection Methods for Fixed Bandwidth

The default kernel in `density.ppp()` is the `gaussian`. But there are other options such as `epanechnikov`, `quartic` or `disc.`

```{r}
kde_fixed_bw_scott.gaussian <- density(grab_origin_ppp_sg_km, 
                          sigma=fixed_bw_scott, 
                          edge=TRUE, 
                          kernel="gaussian")


kde_fixed_bw_scott.epanechnikov <- density(grab_origin_ppp_sg_km, 
                          sigma=fixed_bw_scott, 
                          edge=TRUE, 
                          kernel="epanechnikov")
   
kde_fixed_bw_scott.quartic <- density(grab_origin_ppp_sg_km, 
                          sigma=fixed_bw_scott, 
                          edge=TRUE, 
                          kernel="quartic")
       
   
kde_fixed_scott.disc <- density(grab_origin_ppp_sg_km, 
                          sigma=fixed_bw_scott, 
                          edge=TRUE, 
                          kernel="disc")
         
par(mfrow = c(2,2))
plot(kde_fixed_bw_scott.gaussian, main="Gaussian")
plot(kde_fixed_bw_scott.epanechnikov, main="Epanechnikov")
plot(kde_fixed_bw_scott.quartic, main="Quartic")
plot(kde_fixed_scott.disc, main="Disc")
```

## 

## KDE Layers with Spatially Adaptive Bandwidth

```{r}
kde_adaptive <- adaptive.density(grab_origin_ppp_sg_km, method="kernel")
```

# Comparing Fixed Bandwidth and Adaptive

```{r}
par(mfrow=c(1,2))
plot(kde_fixed_bw_scott.gaussian, main = "Fixed bandwidth")
plot(kde_adaptive, main = "Adaptive bandwidth")
```

## Interactive KDE Maps

## Converting KDE output into grid object into RasterLayer object

We need to convert our KDE output into Grid objects for mapping purposes

```{r}
kde_fixed_bw_scott_raster <- raster(kde_fixed_bw_scott)
kde_adaptive_kernel_raster <- raster(kde_adaptive)
```

Let's perform project transformation

```{r}
projection(kde_fixed_bw_scott_raster) <- CRS("+init=EPSG:3414 +units=km")
projection(kde_adaptive_kernel_raster) <- CRS("+init=EPSG:3414 +units=km")
```

## Kernel Density Maps on OpenStreetMap

Lets visualise our Kernel Density Maps on OpenStreetMap

First we create a mapping function

```{r}
density_map <- function(raster_object, map_title) {
  tm_basemap("OpenStreetMap") +
tm_shape(mpsz_sf) +
    #or mpsz_sf
  tm_raster("v", alpha=0.65) + 
  tm_layout(legend.position = c("right", "bottom"), 
            legend.height = 0.5, 
            legend.width = 0.4,
            main.title = map_title,
            main.title.position = 'center',
            main.title.size = 1,
            frame = FALSE)
  } 
```

Plotting Density Map

```{r}
kde_fixed_bw_scott_map <- density_map(kde_fixed_bw_scott_raster, map_title = "Grab Origin KDE Fixed Bandwidth (Scott Method)")
kde_adaptive_kernel_map <- density_map(kde_adaptive_kernel_raster, map_title = "Grab Origin KDE Adaptive Bandwidth")
```

```{r}
tmap_mode('view')
kde_fixed_bw_scott_map <- tm_basemap("OpenStreetMap") +
  tm_shape(kde_fixed_bw_scott_raster) +
  tm_raster(alpha = 0.65, title = "KDE_Fixed_Scott", palette = brewer.pal(12, "Set3")) +
  tm_layout(title = "Grab Origin KDE Fixed Bandwidth (Scott Method)")
tmap_leaflet(kde_fixed_bw_scott_map)

```

```{r}
tmap_mode('view')
kde_adaptive_kernel_map <- tm_basemap("OpenStreetMap") +
  tm_shape(kde_adaptive_kernel_raster) +
  tm_raster(alpha = 0.65, title = "KDE_Adaptive_Kernel", palette = brewer.pal(12, "Set3")) +
  tm_layout(title = "Grab Origin KDE Adaptive Bandwidth")
tmap_leaflet(kde_adaptive_kernel_map)

```

## Kernel Density Map Analysis

## **Comparing Spatial Point Patterns using KDE**

## Extract Planning Areas

```{r}
je = mpsz_sf%>%filter(PLN_AREA_N == "JURONG EAST")
tm = mpsz_sf%>%filter(PLN_AREA_N == "TAMPINES")
ck = mpsz_sf%>%filter(PLN_AREA_N == "CHOA CHU KANG")
jw = mpsz_sf%>%filter(PLN_AREA_N == "JURONG WEST")
```

## Plotting target planning areas

```{r}
par(mfrow=c(2,2))
plot(st_geometry(je), main = "Jurong East")
plot(st_geometry(tm), main = "Tampines")
plot(st_geometry(ck), main = "Choa Chu Kang")
plot(st_geometry(jw), main = "Jurong West")
```

```{r}
je_owin = as.owin(je)
tm_owin = as.owin(tm)
ck_owin = as.owin(ck)
jw_owin = as.owin(jw)

origin_je_ppp = grab_origin_ppp_sg[je_owin]
origin_tm_ppp = grab_origin_ppp_sg[tm_owin]
origin_ck_ppp = grab_origin_ppp_sg[ck_owin]
origin_jw_ppp = grab_origin_ppp_sg[jw_owin]
```

```{r}
je_kde_scott <- density(origin_je_ppp, sigma=bw.scott, main="Jurong East")
tm_kde_scott <- density(origin_tm_ppp, sigma=bw.scott, main="Tampines")
ck_kde_scott <- density(origin_ck_ppp, sigma=bw.scott, main="Choa Chu Kang")
jw_kde_scott <- density(origin_jw_ppp, sigma=bw.scott, main="Jurong West")


par(mfrow = c(3,2))
plot(je_kde_scott,main = "KDE Jurong East")
plot(tm_kde_scott,main = "KDE Tampines")
plot(ck_kde_scott,main = "KDE Choa Chu Kang")
plot(jw_kde_scott,main = "Jurong West")


```

## Nearest Neighbour Analysis

## Clark-Evans test of aggregation

## Origin Points

The test hypotheses are:

-   H~0~ = The distribution of origin points are randomly distributed

-   H~1~= The distribution of origin points are not randomly distributed

The 95% confident interval will be used.

```{r}
clarkevans.test(grab_origin_ppp_sg,
                correction="none",
                clipregion="sg_owin",
                alternative=c("clustered"),
                nsim=99)
```

## Destination Points

The test hypotheses are:

-   H~0~ = The distribution of destination points are randomly distributed

-   H~1~= The distribution of destination points are not randomly distributed

The 95% confidence interval will be used.

```{r}
clarkevans.test(grab_dest_ppp_sg,
                correction="none",
                clipregion="sg_owin",
                alternative=c("clustered"),
                nsim=99)
```

## **Network Constrained Kernel Density Estimation (NKDE)**
