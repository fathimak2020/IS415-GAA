---
title: "Take-home Exercise 1: Application of Spatial Point Patterns Analysis to Discover the Geographical Distribution of Grab Hailing Services in Singapore"
format: 
  html:
    code-fold: true
    code-summary: "Show the code"
    #toc: false
execute: 
  eval: false
  echo: true
  warning: false
editor: visual
---

# 1 Overview

## 1.1 Setting the scene

Understanding how people move around in a city is like figuring out its heartbeat—it shows us the rhythms that shape our urban lives. Thanks to smartphones and technology, we now have a bunch of data about how people move. When we use smart analysis tools like GIS, we can unlock valuable insights that help us plan cities better.

In 2020, GRAB shared a set of data called Grab Posisi, all about how people move around in Singapore. This kind of information isn't just interesting; it's super helpful for businesses, people who make decisions about the city, and those who plan how cities work. It's like having a dynamic picture of how people move, helping us create cities that work well for everyone.

## 1.2 Objectives

The objectives of this exercise are to:

-   Apply geospatial analytics to address societal challenges

-   Use spatial point patterns analysis methods to explore Grab hailing services distribution in Singapore

-   Organise geospatial data into sf tibble data.frames using sf and tidyverse functions

-   Focus on Grab taxi location points, road layer within Singapore, and Singapore boundary layer

-   Generate traditional Kernel Density Estimation layers from the extracted data

-   Create either Network Kernel Density Estimation (NKDE)

-   Utilise tmap functions to display kernel density layers on an openstreetmap of Singapore

-   Describe spatial patterns revealed by the kernel density maps

By this exercise, I will:

-   Enhance my understanding of geospatial analytics applications

-   Develop proficiency in spatial point patterns analysis

-   Gain hands-on experience in organising geospatial data using sf and tidyverse functions

-   Explore Grab hailing services distribution patterns in Singapore

-   Generate and interpret Kernel Density Estimation layers

-   Understand the nuances of Network Kernel Density Estimation (NKDE)

-   Master the visualisation of spatial patterns using tmap functions on an openstreetmap

# 2 Getting Started

## 2.1 Data Acquisition

The study will utilise the following datasets to explore spatial point patterns analysis methods and reveal the geographical and spatio-temporal distribution of Grab hailing services locations in Singapore.

| Dataset Name                               | Type                | Source                                                              | Path                                                  |
|-----------------|-----------------|----------------------|-----------------|
| Grab-Posisi                                | Aspatial (.parquet) | <https://engineering.grab.com/grab-posisi>                          | data/aspatial/grabPosisi                              |
| Master Plan 2019 Subzone Boundary (No Sea) | Geospatial (.shp)   | <https://beta.data.gov.sg/collections/2104/view>                    | data/geospatial/MasterPlan2019SubzoneBoundaryNoSeaKML |
| Open Street Map Raod Data                  | Geospatial (.shp)   | <https://download.geofabrik.de/asia/malaysia-singapore-brunei.html> | data/geospatial/OSM/gis_osm_roads_free_1              |

## **2.2 Importing Relevant R Packages**

The R packages used in this project are:

-   `sf`: for importing, managing, and processing geospatial data.

-   `tidyverse`: a family of other R packages for performing data science tasks such as importing, wrangling, and visualising data.

-   `tmap`: creating thematic maps

-   `maptools`: a set of tools for manipulating geographic data

-   `raster`: reads, writes, manipulates, analyses, and model gridded spatial data (raster)

-   `spatstat`: for performing spatial point patterns analysis

-   `dplyr`

-   `arrow`

-   `lubridate`: undefined

-   `rgdal`

Pacman assists us by helping us load R packages that we require.

```{r}
pacman::p_load(arrow, lubridate, tidyverse, tmap, sf, maptools, spatstat, raster, dplyr, rmapshaper)

## install.packages("maptools", repos = "https://packagemanager.posit.co/cran/2023-10-13")
```

## 2.3 Importing Geospatial Datasets

## 2.3.1 Master Plan 2019 Subzone Boundary (No Sea)

For the shapefile format, two arguments are required: `dsn` to define the data path, and `layer` to provide the shapefile name. 

```{r}
mpsz_sf <- st_read(dsn = "data/geospatial", 
                layer = "MPSZ-2019") %>% st_transform(crs = 3414)
```

::: callout-important
**Project Transformation**

Given that our dataset corresponds to the geographical boundaries of Singapore, it's essential to specify the appropriate CRS for accurate spatial analysis. To achieve this, the **`st_transform()`** function is used to convert the CRS of `mpsz_sf` to SVY21 (EPSG: 3414)
:::

## 2.3.2 Coastal Outline

In order to create a costal outline of singapore, we will use the `st_union` function to consolidate all subzone boundaries into a single polygon.

```{r}
outline = mpsz_sf %>% st_union()
plot(outline)
```

## 2.3.2.1 Extracting outer islands

As seen in the figure above, the coastal outline includes outer islands where Grab service is unavailable. Through the code chunk below, we shall use the `subset` function to select planning subzones from the `mpsz_sf` dataset to exclude. These rows of data are stored in new dataframes.

```{r}
semakau <- subset(mpsz_sf,mpsz_sf$SUBZONE_N == "SEMAKAU")
sudong <- subset(mpsz_sf, mpsz_sf$SUBZONE_N == "SUDONG")
north <- subset(mpsz_sf, mpsz_sf$SUBZONE_N == "NORTH-EASTERN ISLANDS")
south <- subset(mpsz_sf, mpsz_sf$SUBZONE_N == "SOUTHERN GROUP")
```

We combine the newly created dataframes using the `bind_rows` function.

```{r}
outerislands <- dplyr::bind_rows(list(semakau,sudong,north,south))
```

## 2.3.2.2 Rendering a Coastal Boundary Excluding Outer Islands

We use the st_union function to merge the geometries of `mpsz_sf` and `outerislands` and the `st_difference` function to eliminate the overlap.

```{r}
sg_sf <- st_difference(st_union(mpsz_sf), st_union(outerislands))
plot(sg_sf)
```

::: callout-tip
✅ Task Complete! We have extracted Singapore boundary layer excluding outer islands.
:::

## 2.3.3 Open Street Map Road Data

```{r}
#| eval: false
allroads = st_read(dsn = "data/geospatial/OSM", 
                         layer = "gis_osm_roads_free_1")  %>% st_transform(crs = 3414)
```

::: callout-important
**Project Transformation**

Given that our dataset corresponds to the geographical boundaries of Singapore, it's essential to specify the appropriate CRS for accurate spatial analysis. To achieve this, the **`st_transform()`** function is used to convert the CRS of `allroads` to SVY21 (EPSG: 3414)
:::

This dataset encompasses road networks spanning Singapore, Malaysia, and Brunei. To narrow our focus, we will extract roads exclusively within the Singapore boundary using the `st_intersection` function.

```{r}
#| eval: false
sg_roads_all <- st_intersection(allroads,sg_sf)
```

Next, we will examine the road network's road types.

```{r}
unique(sg_roads_all$fclass)
```

Given our focus on Grab services, which primarily operate on motorways, we will extract the motorway type from the road network.

```{r}
#sg_roads <- sg_roads_all %>%
 # filter(class == "motorway")
```

We will now visualise the motorway road type within the boundaries of Singapore.

```{r}
tm_shape(sg_sf) +   tm_borders(lwd = 2, col = 'grey') +   tm_shape(sg_roads_all) +   tm_lines(col = 'brown4') +   tm_layout(frame = FALSE)
```

::: callout-tip
✅ Task Complete! Road layer within Singapore excluding outer islands.
:::

## 2.4 Importing Aspatial Datasets

## 2.4.1 Grab-Posisi

Grab-Posisi, is a GPS trajectory dataset. Each trajectory is serialised in a file in Apache Parquet format. 

We will use the `read_parquet` function from the `arrow` package, to read Parquet files.

```{r}
grab0 <- read_parquet("data/aspatial/GrabPosisi/part-00000.parquet", as_data_frame = TRUE)
grab1 <- read_parquet("data/aspatial/GrabPosisi/part-00001.parquet", as_data_frame = TRUE)
grab2 <- read_parquet("data/aspatial/GrabPosisi/part-00002.parquet", as_data_frame = TRUE)
grab3 <- read_parquet("data/aspatial/GrabPosisi/part-00003.parquet", as_data_frame = TRUE)
grab4 <- read_parquet("data/aspatial/GrabPosisi/part-00004.parquet", as_data_frame = TRUE)
grab5 <- read_parquet("data/aspatial/GrabPosisi/part-00005.parquet", as_data_frame = TRUE)
grab6 <- read_parquet("data/aspatial/GrabPosisi/part-00006.parquet", as_data_frame = TRUE)
grab7 <- read_parquet("data/aspatial/GrabPosisi/part-00007.parquet", as_data_frame = TRUE)
grab8 <- read_parquet("data/aspatial/GrabPosisi/part-00008.parquet", as_data_frame = TRUE)
grab9 <- read_parquet("data/aspatial/GrabPosisi/part-00009.parquet", as_data_frame = TRUE)
```

Then we join all into one dataframe.

```{r}
#| eval: false
grab <- bind_rows(grab0,grab1, grab2,grab3,grab4,grab5,grab6,grab7,grab8,grab9) 
```

```{r}
head(grab)
```

The `head` function reveals that there are 9 columns in the dataframe.

The field `pingtimestamp` is not in proper date-time format. It is stored as an `int` value. The following code chunk converts the data type of `pingtimestamp` from `int` to `date-time` format.

```{r}
#| eval: false
grab$pingtimestamp <- as_datetime(grab$pingtimestamp)
```

## 2.4.1.2 Converting Aspatial Data Frame into a Simple Feature Data Frame

We will proceed to convert the `grab` dataset, currently in an aspatial data frame, into an sf tibble dataframe.

```{r}
#| eval: false
grab_sf <- st_as_sf(grab, 
                       coords = c("rawlng", "rawlat"),
                       crs=4326) %>%
  st_transform(crs = 3414)
```

::: callout-important
**Project Transformation**

Assuming the dataset is initially in the WGS84 Geographic Coordinate System, as indicated by its latitude/longitude fields, we need to define the suitable CRS for spatial analysis within Singapore. The `st_transform()` function is utilised to convert the CRS of the `grab` dataset to SVY21 (EPSG: 3414).
:::

This gives us the new simple feature data frame, `grab_sf`

## 2.4.2 Data Wrangling

## 2.4.2.1 **Extracting Grab Trips Starting Locations**

We will extract trip starting point for all unqiue trajectories and store them to a new df named `grab_origin`. To isolate the origin locations, we employ the following methodology:

1.  **Grouping by Trajectory ID:**

    -   The dataset is grouped by the unique trajectory identifier (**`trj_id`**).

2.  **Arranging by Timestamp:**

    -   Within each trajectory group, records are arranged in ascending order based on the timestamp (**`pingtimestamp`**).

3.  **Filtering for the First Row:**

    -   By selecting the first row within each grouped trajectory (**`row_number() == 1`**), we identify the earliest recorded location for each trip. This is indicative of the trip's starting point.

4.  **Adding Temporal Information:**

    -   Additional temporal context is provided by introducing new columns:

        -   **`weekday`**: Day of the week based on the timestamp.

        -   **`start_hr`**: Starting hour of the trip.

        -   **`day`**: Day of the month when the trip commenced.

```{r}
grab_origin <- grab_sf %>%
  group_by(trj_id) %>%
  arrange (pingtimestamp) %>%
  filter(row_number()==1) %>% #after sorting by timestamp, first row gives origin location 
  mutate(weekday = wday(pingtimestamp, #define workday
                        label = TRUE,
                        abbr = TRUE), #Monday = MON 
        start_hr = factor(hour(pingtimestamp)),
        day = factor(mday(pingtimestamp))) #to change to ordinal scale
```

```{r}
#rds
```

::: callout-tip
✅ Task Complete! Grab taxi location points either by origins or destinations.
:::

## 2.4.2.2 **Extracting Trip Ending Locations**

We will extract trip ending point for all unique trajectories and store them to a new df named `grab_dest`. We employ a similar methodology to extracting a trips origin location. Except here, within each trajectory group, records are arranged in descending order based on the timestamp (**`pingtimestamp`**). By selecting the first row within each grouped trajectory (**`row_number() == 1`**), we identify the latest recorded location for each trip. This corresponds to the trip's ending point.

```{r}
grab_dest <- grab_sf %>%
  group_by(trj_id) %>%
  arrange(desc(pingtimestamp)) %>% #function from dplyr
  filter(row_number()==1) %>% #first row after arranging in desc order gives dest  
  mutate(weekday = wday(pingtimestamp, #define workday
                        label = TRUE,
                        abbr = TRUE), #Monday = MON 
        end_hr = factor(hour(pingtimestamp)),
        day = factor(mday(pingtimestamp))) #to change to ordinal scale
```

```{r}
#rds  
```

::: callout-tip
✅ Task Complete! Grab taxi location points either by origins or destinations.
:::

## Converting the Simple Features to Planar Point Pattern Object

Firstly, we’ll need to convert the simple features data frames into Spatial\* classes if we can to do SPPA on it:

```{r}
grab_origin_ppp <- as.ppp(st_coordinates(grab_origin), st_bbox(grab_origin))
par(mar = c(0,0,1,0))
plot(grab_origin_ppp)
```

```{r}
grab_dest_ppp <- as.ppp(st_coordinates(grab_dest), st_bbox(grab_dest))
par(mar = c(0,0,1,0))
plot(grab_dest_ppp)
```

::: callout-tip
Note: It is not neccesary to change `sg_sf` into a ppp object as it will be converted to `owin` instead.
:::

## Check for duplicates and Handle Data Errors

```{r}
summary(grab_origin_ppp)
summary(grab_dest_ppp)
```

Note: grab_origin_ppp objecs has no duplicated points, just to be sure, check again

```{r}
any(duplicated(grab_origin_ppp)) 
any(duplicated(grab_dest_ppp)) 
```

##Introducing the owin object

Usually, when analysing spatial point patterns, we’ll confine our analysis within a certain geographical area - such as the Singapore boundary. In spatstat, an object called owin is specially designed to represent this polygonal region.

##Creating owin object

```{r}
sg_owin <- as(sg_sf, "owin")
plot(sg_owin)
```

## Combining Point Events and OWIN Object

Now, we’ll extract the relevant events that are located within Singapore.

```{r}
grab_origin_ppp_sg <- grab_origin_ppp[sg_owin]
plot(grab_origin_ppp_sg)
```

```{r}
grab_dest_ppp_sg <- grab_dest_ppp[sg_owin]
plot(grab_dest_ppp_sg)
```

## Exploratoty Spatial Data Analysis

`grab_original_ppp_sg` and `grab_dest_ppp_sg` is in metres. For futher analysis, we are required to rescale our data to kilometers, we can do so using `rescale()`

```{r}
grab_origin_ppp_sg_km <- rescale(grab_origin_ppp_sg, 1000, 'km')
grab_dest_ppp_sg_km <- rescale(grab_dest_ppp_sg, 1000, 'km')
```

##First-Order Spatial Point Patterns Analysis

Computing kernel density estimation using automatic bandwidth selection method

```{r}
kde_grab_origin_sg_bw <- density(grab_origin_ppp_sg_km,
                                   sigma=bw.diggle,
                                   edge=TRUE,
                                   kernel="gaussian")
```

```{r}
plot(kde_grab_origin_sg_bw,main = "Default Density KDE for Origin Points")
```

```{r}
kde_grab_dest_sg_bw <- density(grab_dest_ppp_sg_km,
                                   sigma=bw.diggle,
                                   edge=TRUE,
                                   kernel="gaussian")
```

```{r}
plot(kde_grab_dest_sg_bw,main = "Default Density KDE for Destination Points")
```

## Converting KDE output into grid object into RasterLayer object

```{r}
kde_grab_origin_sg_bw_raster <- kde_grab_origin_sg_bw %>% 
  as.SpatialGridDataFrame.im() %>% 
  raster()

kde_grab_dest_sg_bw_raster <- kde_grab_dest_sg_bw %>% 
  as.SpatialGridDataFrame.im() %>% 
  raster()
```

Let's check the properties of our ratser layers

```{r}
kde_grab_origin_sg_bw_raster
```

There is no CRS assigned so we shall do so in the next step.

```{r}
projection(kde_grab_origin_sg_bw_raster) <- CRS("+init=EPSG:3414 +datum=WGS84 +units=km")
projection(kde_grab_dest_sg_bw_raster) <- CRS("+init=EPSG:3414 +datum=WGS84 +units=km")
```

## Kernel Density Maps on OpenStreetMap

Making a Density Map function

```{r}
density_map <- function(raster_object, map_title) {
  tm_basemap("OpenStreetMap") +
tm_shape(raster_object) +
  tm_raster("v", alpha=0.65) + 
  tm_layout(legend.position = c("right", "bottom"), 
            legend.height = 0.5, 
            legend.width = 0.4,
            main.title = map_title,
            main.title.position = 'center',
            main.title.size = 1,
            frame = FALSE)
  } 
```

Plotting Density Map

```{r}
grab_origin_density_map <- density_map(kde_grab_origin_sg_bw_raster, map_title = "Grab Origin Point Density Map")
grab_dest_density_map <- density_map(kde_grab_dest_sg_bw_raster, map_title = "Grab Destination Point Density Map")
```

## Kernel Density Map Analysis
