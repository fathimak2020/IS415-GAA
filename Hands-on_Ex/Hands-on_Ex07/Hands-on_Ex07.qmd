---
title: "Hands-on Exercise 7: Geographic Segmentation with Spatially Constrained Cluster Analysis"
format:
  html:
    toc: true
execute: 
  warning: false
  eval: true
  freeze: true
  fig-retine: 3
date: "`r format(Sys.Date(), '%Y-%m-%d')`"
date-modified: "last-modified"
---

# Overview

In this in-class exercise, we will gain hands-on experience on how to delineate homogeneous region by using geographically referenced multivariate data. There are two major analysis, namely:

-   hierarchical cluster analysis
-   spatially constrained cluster analysis

# Learning Outcome

By the end of this hands-on exercise, we will able:

-   to convert GIS polygon data into R’s simple feature data.frame by using appropriate functions of sf package of R

-   to convert simple feature data.frame into R’s SpatialPolygonDataFrame object by using appropriate sf of package of R

-   to perform custer analysis by using hclust() of Base R

-   to perform spatially constrained cluster analysis using skater() of Base R

-   and to visualise the analysis output by using ggplot2 and tmap package

# Getting Started

## The analytical question

We are interested to delineate Shan State, Myanmar into homogeneous regions by using multiple Information and Communication technology (ICT) measures, namely: Radio, Television, Land line phone, Mobile phone, Computer, and Internet at home.

## The data

Two data sets will be used in this study. They are:

-   **Myanmar Township Boundary Data** : This is a GIS data in ESRI shapefile format. It consists of township boundary information of Myanmar. The spatial data are captured in polygon features.

-   **Shan-ICT.csv**: This is an extract of The 2014 Myanmar Population and Housing Census Myanmar at the township level. Both data sets are download from Myanmar Information Management Unit (MIMU)

## Installing and loading R packages

Before we get started, it is important for us to install the necessary R packages into R and launch these R packages into R environment.

The R packages needed for this exercise are as follows:

The code chunks below installs and launches these R packages into R environment.

```{r}
pacman::p_load(sp, spdep, tmap, sf, ClustGeo, 
               ggpubr, cluster, factoextra, NbClust,
               heatmaply, corrplot, psych, tidyverse, GGally)
```

Note: rgdal is retired so we use spdep instead. dplyr is included in tidyverse.

## Data Import and Prepatation

### Importing geospatial data into R environment

```{r}
#
shan_sf <- st_read(dsn = "data/geospatial", 
                   layer = "myanmar_township_boundaries") %>%
  filter(ST %in% c("Shan (East)", "Shan (North)", "Shan (South)")) %>%
  select(c(2:7))
```

Note: The filter function from dplyr has been added to explicitly filter out Shan boundary.Select function is used to select relevant fields.

```{r}
shan_sf
```

### Importing aspatial data into R environment

The csv file will be import using read_csv function of readr package.

The code chunks used are shown below:

```{r}
ict <- read_csv ("data/aspatial/Shan-ICT.csv")
```

The imported InfoComm variables are extracted from The 2014 Myanmar Population and Housing Census Myanmar. The attribute data set is called ict. It is saved in R’s \* tibble data.frame\* format.

The code chunk below reveal the summary statistics of ict data.frame.

```{r}
summary(ict)
```

### Derive new variables using dplyr package

```{r}
ict_derived <- ict %>%
  mutate(`RADIO_PR` = `Radio`/`Total households`*1000) %>%
  mutate(`TV_PR` = `Television`/`Total households`*1000) %>%
  mutate(`LLPHONE_PR` = `Land line phone`/`Total households`*1000) %>%
  mutate(`MPHONE_PR` = `Mobile phone`/`Total households`*1000) %>%
  mutate(`COMPUTER_PR` = `Computer`/`Total households`*1000) %>%
  mutate(`INTERNET_PR` = `Internet at home`/`Total households`*1000) %>%
  rename(`DT_PCODE` =`District Pcode`,`DT`=`District Name`,
         `TS_PCODE`=`Township Pcode`, `TS`=`Township Name`,
         `TT_HOUSEHOLDS`=`Total households`,
         `RADIO`=`Radio`, `TV`=`Television`, 
         `LLPHONE`=`Land line phone`, `MPHONE`=`Mobile phone`,
         `COMPUTER`=`Computer`, `INTERNET`=`Internet at home`) 
```

Perform scaling on the data as range is wide, them rename fields to make them shorter.

```{r}
summary(ict_derived)
```

## Exploratory Data Analysis (EDA)

### EDA using statistical graphics

```{r, fig.width =4, fig.height=6}
ggplot(data=ict_derived, 
       aes(x=`RADIO`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")
```

```{r}
ggplot(data=ict_derived, 
       aes(x=`RADIO`)) +
  geom_boxplot(color="black", 
               fill="light blue")
```

```{r}
ggplot(data=ict_derived, 
       aes(x=`RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")
```

```{r}
ggplot(data=ict_derived, 
       aes(x=`RADIO_PR`)) +
  geom_boxplot(color="black", 
               fill="light blue")
```

```{r, echo = FALSE, eval = TRUE, fig.width = 10}
radio <- ggplot(data=ict_derived, 
             aes(x= `RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

tv <- ggplot(data=ict_derived, 
             aes(x= `TV_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

llphone <- ggplot(data=ict_derived, 
             aes(x= `LLPHONE_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

mphone <- ggplot(data=ict_derived, 
             aes(x= `MPHONE_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

computer <- ggplot(data=ict_derived, 
             aes(x= `COMPUTER_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

internet <- ggplot(data=ict_derived, 
             aes(x= `INTERNET_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")
```

```{r}
ggarrange(radio, tv, llphone, mphone, computer, internet, 
          ncol = 3, 
          nrow = 2)
```
Note: ggrange is used to stitch the plots together

### EDA using choropleth map

#### Joining geospatial data with aspatial data

```{r}
shan_sf <- left_join(shan_sf, 
                     ict_derived, by=c("TS_PCODE"="TS_PCODE"))
  
write_rds(shan_sf, "data/rds/shan_sf.rds")
```

Note: for joins, add geometric file then attribute file. for spjoin, both files must be spatial. all sp function belong to sf and are designed to handle spatial features   

## Correlation Analysis

```{r}
cluster_vars.cor = cor(ict_derived[,12:17])
corrplot.mixed(cluster_vars.cor,
         lower = "ellipse", 
               upper = "number",
               tl.pos = "lt",
               diag = "l",
               tl.col = "black")
```
Note: Size of ellips shows correlation. Small shows that there is low correlation. Blue is postive correlation, red is negative correlation.

### Extracting Clustering Varaibles

```{r}
cluster_vars <- shan_sf %>%
  st_set_geometry(NULL) %>%
  select("TS.x", "RADIO_PR", "TV_PR", "LLPHONE_PR", "MPHONE_PR", "COMPUTER_PR")
head(cluster_vars,10)
```
```{r}
row.names(cluster_vars) <- cluster_vars$"TS.x"
head(cluster_vars,10)
```
Note: This is to replace row numbers with row names. 

```{r}
shan_ict <- select(cluster_vars, c(2:6))
head(shan_ict, 10)
```

```{r}
write_rds(shan_ict, "data/rds/shan_ict.rds")
```

## Min-max standardisation

```{r}
shan_ict.std <- normalize(shan_ict)
summary(shan_ict.std)
```

## z-score standardisation

```{r}
shan_ict.z <- scale(shan_ict)
describe(shan_ict.z)
```

### Visualising the standardised clustering variables

```{r}
r <- ggplot(data=ict_derived, 
             aes(x= `RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  ggtitle("Raw values without standardisation")

shan_ict_s_df <- as.data.frame(shan_ict.std)
s <- ggplot(data=shan_ict_s_df, 
       aes(x=`RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  ggtitle("Min-Max Standardisation")

shan_ict_z_df <- as.data.frame(shan_ict.z)
z <- ggplot(data=shan_ict_z_df, 
       aes(x=`RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  ggtitle("Z-score Standardisation")

ggarrange(r, s, z,
          ncol = 3,
          nrow = 1)
```

```{r}
r <- ggplot(data=ict_derived, 
             aes(x= `RADIO_PR`)) +
  geom_density(color="black",
               fill="light blue") +
  ggtitle("Raw values without standardisation")

shan_ict_s_df <- as.data.frame(shan_ict.std)
s <- ggplot(data=shan_ict_s_df, 
       aes(x=`RADIO_PR`)) +
  geom_density(color="black",
               fill="light blue") +
  ggtitle("Min-Max Standardisation")

shan_ict_z_df <- as.data.frame(shan_ict.z)
z <- ggplot(data=shan_ict_z_df, 
       aes(x=`RADIO_PR`)) +
  geom_density(color="black",
               fill="light blue") +
  ggtitle("Z-score Standardisation")

ggarrange(r, s, z,
          ncol = 3,
          nrow = 1)
```

### Computing proximity matrix 

```{r}
proxmat <- dist(shan_ict, method = 'euclidean')
```

### Computing Hierarchical Clustering

```{r}
hclust_ward <- hclust(proxmat, method = 'ward.D')
```

```{r}
plot(hclust_ward, cex = 0.6)
```

## Determining Optimal Number of Clusters

```{r}
set.seed(12345)
gap_stat <- clusGap(shan_ict, 
                    FUN = hcut, 
                    nstart = 25, 
                    K.max = 10, 
                    B = 50)
# Print the result
print(gap_stat, method = "firstmax")
```

```{r}
fviz_gap_stat(gap_stat)
```

```{r}
plot(hclust_ward, cex = 0.6)
rect.hclust(hclust_ward, 
            k = 6, 
            border = 2:5)
```

## Mapping the clusters formed 
```{r}
groups <- as.factor(cutree(hclust_ward, k=6))
```

```{r}
shan_sf_cluster <- cbind(shan_sf, as.matrix(groups)) %>%
  rename(`CLUSTER`=`as.matrix.groups.`)
```
Note: cbind is used instead of join as there is no unqiue identifier in the list and order of list has not been changes.

```{r}
qtm(shan_sf_cluster, "CLUSTER")
```

## Spatially Constrained Clustering: SKATER approach

```{r}
shan.nb <- poly2nb(shan_sf)
summary(shan.nb)
```

```{r}
plot(st_geometry(shan_sf), 
     border=grey(.5))

pts <- st_coordinates(st_centroid(shan_sf))
plot(shan.nb,
     pts,
     col="blue",
     add=TRUE)
```

Note: Use sf version instead of sp version.

